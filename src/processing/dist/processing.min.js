!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).tool={})}(this,(function(e){"use strict";class t extends Map{constructor(e,t=l){if(super(),Object.defineProperties(this,{_intern:{value:new Map},_key:{value:t}}),null!=e)for(const[t,n]of e)this.set(t,n)}get(e){return super.get(n(this,e))}has(e){return super.has(n(this,e))}set(e,t){return super.set(function({_intern:e,_key:t},n){const l=t(n);return e.has(l)?e.get(l):(e.set(l,n),n)}(this,e),t)}delete(e){return super.delete(function({_intern:e,_key:t},n){const l=t(n);e.has(l)&&(n=e.get(l),e.delete(l));return n}(this,e))}}function n({_intern:e,_key:t},n){const l=t(n);return e.has(l)?e.get(l):n}function l(e){return null!==e&&"object"==typeof e?e.valueOf():e}function o(e){return e}function r(e,...n){return function(e,n,l,o){return function e(r,f){if(f>=o.length)return l(r);const u=new t,i=o[f++];let s=-1;for(const e of r){const t=i(e,++s,r),n=u.get(t);n?n.push(e):u.set(t,[e])}for(const[t,n]of u)u.set(t,e(n,f));return n(u)}(e,0)}(e,Array.from,o,n)}const f={mean:function(e,t){let n=0,l=0;if(void 0===t)for(let t of e)null!=t&&(t=+t)>=t&&(++n,l+=t);else{let o=-1;for(let r of e)null!=(r=t(r,++o,e))&&(r=+r)>=r&&(++n,l+=r)}if(n)return l/n},deviation:function(e,t){const n=function(e,t){let n,l=0,o=0,r=0;if(void 0===t)for(let t of e)null!=t&&(t=+t)>=t&&(n=t-o,o+=n/++l,r+=n*(t-o));else{let f=-1;for(let u of e)null!=(u=t(u,++f,e))&&(u=+u)>=u&&(n=u-o,o+=n/++l,r+=n*(u-o))}if(l>1)return r/(l-1)}(e,t);return n?Math.sqrt(n):n},flatGroup:function(e,...t){return function(e,t){for(let n=1,l=t.length;n<l;++n)e=e.flatMap((e=>e.pop().map((([t,n])=>[...e,t,n]))));return e}(r(e,...t),t)}};e.fillMeanColumnMissing=function(e){const t=Array.from({length:e[0].length},((t,n)=>f.mean(e,(e=>e[n]))));for(const n of e)for(let e=0;e<n.length;e++)null==n[e]&&(n[e]=t[e]);return e},e.interpolateMissing=function(e){function t(e){for(let t=0;t<e.length;t++)if(null==e[t]){let n=t,l=t;for(let t=n+1;t<e.length;t++)if(null!=e[t]){l=t;break}if(0==n)for(let t=n;t<l;t++)e[t]=e[l];else if(n==l){n--;for(let t=n+1;t<l+1;t++)e[t]=e[n]}else{const t=e[n-1],o=e[l];for(let r=n;r<l;r++){const f=(r-n+1)/(l-n+1);e[r]=t+(o-t)*f}}}return e}for(const n of e)t(n);return e},e.movingAverageSmooth=function(e,t=1,n="fill_null"){const l=[],o="cut_window"==n?0:t,r="cut_window"==n?e.length:e.length-t;for(let n=o;n<r;n++){const o=Math.max(0,n-t),r=Math.min(n+t,e.length-1);let f=0;for(let t=o;t<=r;t++)f+=e[t];l[n]=f/(r-o+1)}if("fill_null"==n)for(let e=0;e<t;e++)l[e]=null,l.push(null);else if("shorten"==n)return Object.values(l);return l},e.zNormalize=function(e,t="row"){let n=e.map((e=>[...e]));if("column"==t||"both"==t)for(let t=0;t<e[0].length;t++){let l=f.mean(e,(e=>e[t])),o=f.deviation(e,(e=>e[t]));if(null!=l&&null!=o){0==o&&(o=1);for(let r=0;r<e.length;r++)n[r][t]=(n[r][t]-l)/o}else for(let l=0;l<e.length;l++)n[l][t]=NaN}if("row"==t||"both"==t)for(let e=0;e<n.length;e++){let t=f.mean(n[e]),l=f.deviation(n[e]);if(null!=t&&null!=l){0==l&&(l=1);for(let o=0;o<n[e].length;o++)n[e][o]=(n[e][o]-t)/l}else for(let t=0;t<n[e].length;t++)n[e][t]=NaN}return n}}));
