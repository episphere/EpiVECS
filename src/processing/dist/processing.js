class t extends Map{constructor(t,e=n){if(super(),Object.defineProperties(this,{_intern:{value:new Map},_key:{value:e}}),null!=t)for(const[e,n]of t)this.set(e,n)}get(t){return super.get(e(this,t))}has(t){return super.has(e(this,t))}set(t,e){return super.set(function({_intern:t,_key:e},n){const l=e(n);return t.has(l)?t.get(l):(t.set(l,n),n)}(this,t),e)}delete(t){return super.delete(function({_intern:t,_key:e},n){const l=e(n);t.has(l)&&(n=t.get(l),t.delete(l));return n}(this,t))}}function e({_intern:t,_key:e},n){const l=e(n);return t.has(l)?t.get(l):n}function n(t){return null!==t&&"object"==typeof t?t.valueOf():t}function l(t){return t}function r(e,...n){return function(e,n,l,r){return function e(o,f){if(f>=r.length)return l(o);const u=new t,i=r[f++];let s=-1;for(const t of o){const e=i(t,++s,o),n=u.get(e);n?n.push(t):u.set(e,[t])}for(const[t,n]of u)u.set(t,e(n,f));return n(u)}(e,0)}(e,Array.from,l,n)}const o={mean:function(t,e){let n=0,l=0;if(void 0===e)for(let e of t)null!=e&&(e=+e)>=e&&(++n,l+=e);else{let r=-1;for(let o of t)null!=(o=e(o,++r,t))&&(o=+o)>=o&&(++n,l+=o)}if(n)return l/n},deviation:function(t,e){const n=function(t,e){let n,l=0,r=0,o=0;if(void 0===e)for(let e of t)null!=e&&(e=+e)>=e&&(n=e-r,r+=n/++l,o+=n*(e-r));else{let f=-1;for(let u of t)null!=(u=e(u,++f,t))&&(u=+u)>=u&&(n=u-r,r+=n/++l,o+=n*(u-r))}if(l>1)return o/(l-1)}(t,e);return n?Math.sqrt(n):n},flatGroup:function(t,...e){return function(t,e){for(let n=1,l=e.length;n<l;++n)t=t.flatMap((t=>t.pop().map((([e,n])=>[...t,e,n]))));return t}(r(t,...e),e)}};function f(t,e=1,n="fill_null"){const l=[],r="cut_window"==n?0:e,o="cut_window"==n?t.length:t.length-e;for(let n=r;n<o;n++){const r=Math.max(0,n-e),o=Math.min(n+e,t.length-1);let f=0;for(let e=r;e<=o;e++)f+=t[e];l[n]=f/(o-r+1)}if("fill_null"==n)for(let t=0;t<e;t++)l[t]=null,l.push(null);else if("shorten"==n)return Object.values(l);return l}function u(t,e="row"){let n=t.map((t=>[...t]));if("column"==e||"both"==e)for(let e=0;e<t[0].length;e++){let l=o.mean(t,(t=>t[e])),r=o.deviation(t,(t=>t[e]));if(null!=l&&null!=r){0==r&&(r=1);for(let o=0;o<t.length;o++)n[o][e]=(n[o][e]-l)/r}else for(let l=0;l<t.length;l++)n[l][e]=NaN}if("row"==e||"both"==e)for(let t=0;t<n.length;t++){let e=o.mean(n[t]),l=o.deviation(n[t]);if(null!=e&&null!=l){0==l&&(l=1);for(let r=0;r<n[t].length;r++)n[t][r]=(n[t][r]-e)/l}else for(let e=0;e<n[t].length;e++)n[t][e]=NaN}return n}function i(t){function e(t){for(let e=0;e<t.length;e++)if(null==t[e]){let n=e,l=e;for(let e=n+1;e<t.length;e++)if(null!=t[e]){l=e;break}if(0==n)for(let e=n;e<l;e++)t[e]=t[l];else if(n==l){n--;for(let e=n+1;e<l+1;e++)t[e]=t[n]}else{const e=t[n-1],r=t[l];for(let o=n;o<l;o++){const f=(o-n+1)/(l-n+1);t[o]=e+(r-e)*f}}}return t}for(const n of t)e(n);return t}function s(t){const e=Array.from({length:t[0].length},((e,n)=>o.mean(t,(t=>t[n]))));for(const n of t)for(let t=0;t<n.length;t++)null==n[t]&&(n[t]=e[t]);return t}export{s as fillMeanColumnMissing,i as interpolateMissing,f as movingAverageSmooth,u as zNormalize};
